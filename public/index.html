<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ü§ñ Trading Bot ML Real - IA Avan√ßada Integrada</title>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e1e2e 0%, #2d2d42 50%, #3e3e56 100%);
            color: #fff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Login Modal */
        .login-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .login-form {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 40px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 500px;
            width: 90%;
            text-align: center;
        }

        .login-form h2 {
            color: #00d4ff;
            margin-bottom: 30px;
            font-size: 2rem;
        }

        .account-type-selector {
            display: flex;
            gap: 15px;
            margin-bottom: 25px;
            justify-content: center;
        }

        .account-card {
            flex: 1;
            padding: 20px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.05);
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            position: relative;
        }

        .account-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        }

        .account-card.selected {
            border-color: #00d4ff;
            background: rgba(0, 212, 255, 0.1);
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.3);
        }

        .account-card.demo.selected {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }

        .account-card.real.selected {
            border-color: #ff6b35;
            background: rgba(255, 107, 53, 0.1);
            box-shadow: 0 0 20px rgba(255, 107, 53, 0.3);
        }

        .account-icon {
            font-size: 2.5rem;
            margin-bottom: 10px;
            display: block;
        }

        .account-title {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 5px;
            color: #fff;
        }

        .account-description {
            font-size: 0.9rem;
            opacity: 0.7;
            color: #fff;
        }

        .account-card.demo .account-icon {
            color: #00ff88;
        }

        .account-card.real .account-icon {
            color: #ff6b35;
        }

        .form-group {
            margin-bottom: 20px;
            text-align: left;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #fff;
            font-weight: 500;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: #fff;
            font-size: 16px;
        }

        .form-group input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .login-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(45deg, #00d4ff, #5200ff);
            border: none;
            border-radius: 10px;
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .login-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0, 212, 255, 0.3);
        }

        .login-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .error-message {
            color: #ff4757;
            margin-top: 10px;
            font-size: 14px;
        }

        .success-message {
            color: #00ff88;
            margin-top: 10px;
            font-size: 14px;
        }

        .dashboard-container {
            max-width: 1920px;
            margin: 0 auto;
            padding: 20px;
            display: none;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #00d4ff, #5200ff, #ff6b35);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradientShift 3s ease-in-out infinite;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .status-bar {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-dot.online { background: #00ff88; }
        .status-dot.offline { background: #ff4757; }
        .status-dot.warning { background: #ffa726; }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
        }

        /* ü§ñ PAINEL IA ML REAL EXPANDIDO */
        .ai-panel {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 30px;
            border: 1px solid rgba(0, 212, 255, 0.3);
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.2);
        }

        .ai-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .ai-response {
            background: rgba(0, 212, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            border-left: 4px solid #00d4ff;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .ai-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .ai-btn {
            padding: 10px 16px;
            background: linear-gradient(45deg, #00d4ff, #5200ff);
            border: none;
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .ai-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 212, 255, 0.3);
        }

        .ai-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .ai-btn.active {
            background: linear-gradient(45deg, #00ff88, #00cc6a);
            color: #000;
        }

        /* üéì PAINEL ML STATISTICS */
        .ml-stats-panel {
            background: rgba(0, 255, 136, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #00ff88;
            border: 1px solid rgba(0, 255, 136, 0.3);
            display: none;
        }

        .ml-stats-panel.show {
            display: block;
        }

        .ml-stats-title {
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 10px;
            color: #00ff88;
        }

        .ml-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .ml-stat-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9rem;
        }

        /* üìà PAINEL DE GERENCIAMENTO IA */
        .ai-management {
            background: rgba(0, 255, 136, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #00ff88;
            display: none;
        }

        .ai-management.show {
            display: block;
        }

        .control-panel {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .control-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-item label {
            font-size: 0.9rem;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-item input, .control-item select {
            padding: 10px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
        }

        .control-item select option {
            background: #2d2d42;
            color: #fff;
        }

        .control-item.ai-controlled {
            opacity: 0.6;
            pointer-events: none;
        }

        .control-item.ai-controlled::after {
            content: "ü§ñ IA";
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 212, 255, 0.8);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7rem;
        }

        /* üé∞ PAINEL MARTINGALE INTELIGENTE MELHORADO */
        .martingale-info {
            background: rgba(255, 165, 0, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #ffa726;
            border: 1px solid rgba(255, 165, 0, 0.3);
        }

        .martingale-info.cooling {
            background: rgba(0, 212, 255, 0.1);
            border-left-color: #00d4ff;
            border-color: rgba(0, 212, 255, 0.3);
        }

        .martingale-info.waiting {
            background: rgba(136, 136, 136, 0.1);
            border-left-color: #888;
            border-color: rgba(136, 136, 136, 0.3);
        }

        .martingale-level {
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 8px;
            color: #ffa726;
        }

        .martingale-info.cooling .martingale-level {
            color: #00d4ff;
        }

        .martingale-info.waiting .martingale-level {
            color: #888;
        }

        .next-stake {
            font-size: 1rem;
            margin-bottom: 5px;
            color: #fff;
        }

        .martingale-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            align-items: center;
        }

        .martingale-toggle {
            padding: 5px 12px;
            background: linear-gradient(45deg, #ffa726, #ff8f00);
            border: none;
            border-radius: 6px;
            color: #000;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .martingale-toggle:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 10px rgba(255, 165, 0, 0.3);
        }

        .martingale-toggle.disabled {
            background: rgba(255, 165, 0, 0.3);
            opacity: 0.6;
            cursor: not-allowed;
        }

        .martingale-status {
            font-size: 0.9rem;
            margin-top: 8px;
            padding: 8px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
        }

        .martingale-status.ready {
            color: #00ff88;
        }

        .martingale-status.cooling {
            color: #00d4ff;
        }

        .martingale-status.waiting {
            color: #ffa726;
        }

        /* üìä ORDEM ATIVA INDICATOR */
        .active-order-indicator {
            background: rgba(255, 165, 0, 0.15);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #ffa726;
            border: 1px solid rgba(255, 165, 0, 0.4);
            display: none;
        }

        .active-order-indicator.show {
            display: block;
        }

        .active-order-title {
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 8px;
            color: #ffa726;
        }

        .active-order-details {
            font-size: 0.9rem;
            opacity: 0.9;
            color: #fff;
        }

        .trade-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        .trade-btn {
            padding: 12px 30px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 120px;
        }

        .trade-btn.call {
            background: linear-gradient(45deg, #00ff88, #00cc6a);
            color: #000;
        }

        .trade-btn.put {
            background: linear-gradient(45deg, #ff4757, #ff3742);
            color: #fff;
        }

        .trade-btn.stop {
            background: linear-gradient(45deg, #ffa726, #ff8f00);
            color: #000;
        }

        .trade-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        .trade-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .main-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .metric-card {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .metric-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.4);
        }

        .metric-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .metric-title {
            font-size: 0.9rem;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .metric-icon {
            font-size: 1.5rem;
            opacity: 0.6;
        }

        .metric-value {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #00ff88, #00d4ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .metric-change {
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .metric-change.positive { color: #00ff88; }
        .metric-change.negative { color: #ff4757; }
        .metric-change.neutral { color: #ffa726; }

        .trades-table {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 30px;
        }

        .table-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .trades-grid {
            display: grid;
            grid-template-columns: auto auto auto auto auto auto auto auto auto;
            gap: 10px;
            align-items: center;
            padding: 15px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.9rem;
        }

        .trades-grid:first-child {
            font-weight: bold;
            color: #00d4ff;
            text-transform: uppercase;
            font-size: 0.8rem;
            letter-spacing: 1px;
        }

        .trade-direction {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
            text-align: center;
        }

        .trade-direction.call {
            background: linear-gradient(45deg, #00ff88, #00cc6a);
            color: #000;
        }

        .trade-direction.put {
            background: linear-gradient(45deg, #ff4757, #ff3742);
            color: #fff;
        }

        .trade-status {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
            text-align: center;
        }

        .trade-status.open { background: #ffa726; color: #000; }
        .trade-status.won { background: #00ff88; color: #000; }
        .trade-status.lost { background: #ff4757; color: #fff; }

        .logout-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: rgba(255, 71, 87, 0.2);
            border: 1px solid #ff4757;
            border-radius: 10px;
            color: #ff4757;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .logout-btn:hover {
            background: rgba(255, 71, 87, 0.3);
            transform: translateY(-2px);
        }

        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-left: 4px solid #00d4ff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 10px;
            padding: 15px 20px;
            border-left: 4px solid #00d4ff;
            color: #fff;
            z-index: 9999;
            transform: translateX(400px);
            transition: transform 0.3s ease;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.success { border-left-color: #00ff88; }
        .notification.error { border-left-color: #ff4757; }
        .notification.warning { border-left-color: #ffa726; }

        @media (max-width: 768px) {
            .control-grid {
                grid-template-columns: 1fr;
            }
            
            .trade-buttons {
                flex-direction: column;
            }
            
            .main-grid {
                grid-template-columns: 1fr;
            }
            
            .trades-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 5px;
                font-size: 0.8rem;
            }

            .account-type-selector {
                flex-direction: column;
                gap: 10px;
            }

            .login-form {
                padding: 30px 20px;
                margin: 10px;
            }

            .account-card {
                padding: 15px;
            }

            .account-icon {
                font-size: 2rem;
            }

            .account-title {
                font-size: 1rem;
            }

            .account-description {
                font-size: 0.8rem;
            }

            .ai-controls {
                grid-template-columns: 1fr;
            }

            .ml-stats-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- Modal de Login -->
    <div class="login-modal" id="loginModal">
        <div class="login-form">
            <h2>ü§ñ Trading Bot - IA ML Real</h2>
            
            <!-- Seletor de Tipo de Conta -->
            <div class="account-type-selector">
                <div class="account-card demo selected" onclick="selectAccountType('demo')" id="demoCard">
                    <span class="account-icon">üéÆ</span>
                    <div class="account-title">CONTA DEMO</div>
                    <div class="account-description">ML + IA sem riscos<br>Dinheiro virtual</div>
                </div>
                <div class="account-card real" onclick="selectAccountType('real')" id="realCard">
                    <span class="account-icon">üí∞</span>
                    <div class="account-title">CONTA REAL</div>
                    <div class="account-description">ML + IA real<br>Dinheiro verdadeiro</div>
                </div>
            </div>

            <div class="form-group">
                <label for="apiToken">Token da API Deriv:</label>
                <input type="password" id="apiToken" placeholder="Digite seu token de API da Deriv" required>
            </div>
            
            <select id="accountType" style="display: none;">
                <option value="demo" selected>Demo Account</option>
                <option value="real">Real Account</option>
            </select>
            
            <button class="login-btn" id="loginBtn" onclick="connectAPI()">
                <span id="loginBtnText">üöÄ Conectar API + IA ML</span>
                <div class="loading-spinner" id="loginSpinner" style="display: none; width: 20px; height: 20px; margin: 0 auto;"></div>
            </button>
            <div id="loginMessage"></div>
            <div style="margin-top: 20px; font-size: 0.9rem; opacity: 0.7;">
                <p>‚ÑπÔ∏è Para obter seu token API:</p>
                <p>1. Acesse <a href="https://app.deriv.com/account/api-token" target="_blank" style="color: #00d4ff;">app.deriv.com/account/api-token</a></p>
                <p>2. Crie um novo token com as permiss√µes necess√°rias</p>
                <p>3. Cole o token acima</p>
                <p style="margin-top: 10px; color: #00ff88;">ü§ñ IA REAL + Machine Learning + Martingale Inteligente!</p>
            </div>
        </div>
    </div>

    <!-- Dashboard Principal -->
    <div class="dashboard-container" id="dashboard">
        <button class="logout-btn" onclick="logout()">Logout</button>

        <!-- Header -->
        <div class="header">
            <h1>ü§ñ Trading Bot - ML Real + IA Avan√ßada</h1>
            <p>Conta: <span id="accountInfo">Carregando...</span></p>
            
            <div class="status-bar">
                <div class="status-item">
                    <div class="status-dot offline" id="apiStatus"></div>
                    <span>Deriv API</span>
                </div>
                <div class="status-item">
                    <div class="status-dot offline" id="wsStatus"></div>
                    <span>WebSocket</span>
                </div>
                <div class="status-item">
                    <div class="status-dot offline" id="aiStatus"></div>
                    <span>IA ML Real</span>
                </div>
                <div class="status-item">
                    <div class="status-dot offline" id="tradingStatus"></div>
                    <span>Auto Trading</span>
                </div>
                <div class="status-item">
                    <div class="status-dot offline" id="aiManagementStatus"></div>
                    <span>IA Management</span>
                </div>
            </div>
        </div>

        <!-- ü§ñ PAINEL IA ML REAL EXPANDIDO -->
        <div class="ai-panel">
            <div class="ai-status">
                <h3 style="color: #00d4ff;">ü§ñ Painel IA REAL com Machine Learning</h3>
                <div style="font-size: 0.9rem; opacity: 0.7;">
                    Status: <span id="aiStatusText">Desconectado</span>
                </div>
            </div>
            
            <div id="aiResponse" class="ai-response" style="display: none;">
                <div id="aiResponseText">Aguardando an√°lise da IA ML...</div>
            </div>

            <!-- üéì PAINEL ML STATISTICS -->
            <div id="mlStatsPanel" class="ml-stats-panel">
                <div class="ml-stats-title">üìä Estat√≠sticas Machine Learning</div>
                <div class="ml-stats-grid" id="mlStatsGrid">
                    <!-- Ser√° preenchido dinamicamente -->
                </div>
            </div>

            <!-- üéØ GERENCIAMENTO AUTOM√ÅTICO DA IA -->
            <div id="aiManagement" class="ai-management">
                <h4 style="color: #00ff88; margin-bottom: 10px;">üéØ Gerenciamento Autom√°tico ML</h4>
                <div id="aiManagementText">A IA ML est√° controlando dura√ß√£o e gerenciamento...</div>
            </div>
            
            <div class="ai-controls">
                <button class="ai-btn" onclick="getAIAnalysis()" id="aiAnalyzeBtn" disabled>
                    üîç An√°lise ML
                </button>
                <button class="ai-btn" onclick="getAITradingSignal()" id="aiSignalBtn" disabled>
                    üéØ Sinal ML
                </button>
                <button class="ai-btn" onclick="getAIRiskAssessment()" id="aiRiskBtn" disabled>
                    ‚ö†Ô∏è Risco ML
                </button>
                <button class="ai-btn" onclick="getTechnicalIndicators()" id="aiIndicatorsBtn" disabled>
                    üìà Indicadores
                </button>
                <button class="ai-btn" onclick="trainMLModels()" id="aiTrainBtn" disabled>
                    üéì Treinar ML
                </button>
                <button class="ai-btn" onclick="getMLStatistics()" id="aiStatsBtn" disabled>
                    üìä Stats ML
                </button>
                <button class="ai-btn" onclick="toggleAIDurationControl()" id="aiDurationBtn" disabled>
                    ‚è±Ô∏è Dura√ß√£o IA: OFF
                </button>
                <button class="ai-btn" onclick="toggleAIManagement()" id="aiManagementBtn" disabled>
                    üéõÔ∏è Gerenciamento IA: OFF
                </button>
                <button class="ai-btn" onclick="toggleAIMode()" id="aiModeBtn" disabled>
                    ü§ñ Modo IA: OFF
                </button>
            </div>
            
            <div style="margin-top: 15px; font-size: 0.8rem; opacity: 0.6;">
                üéØ Machine Learning Real: Random Forest + Neural Network + Gradient Boosting<br>
                üìà Indicadores: RSI, MACD, Bollinger, EMAs, Volatilidade, Momentum<br>
                üéì Aprendizado: Cont√≠nuo com feedback dos trades<br>
                üìä API Python: <span id="apiKeyStatus">Conectando...</span> | Status: <span id="connectionMethod">Tentando conex√£o...</span>
            </div>
        </div>

        <!-- M√©tricas -->
        <div class="main-grid">
            <div class="metric-card">
                <div class="metric-header">
                    <span class="metric-title">Saldo</span>
                    <span class="metric-icon">üí∞</span>
                </div>
                <div class="metric-value" id="balance">$0.00</div>
                <div class="metric-change neutral" id="balanceChange">
                    <span>‚Üó</span> Carregando...
                </div>
            </div>

            <div class="metric-card">
                <div class="metric-header">
                    <span class="metric-title">P&L Hoje</span>
                    <span class="metric-icon">üìà</span>
                </div>
                <div class="metric-value" id="todayPnL">$0.00</div>
                <div class="metric-change neutral" id="pnlChange">
                    <span>‚Üó</span> Aguardando dados...
                </div>
            </div>

            <div class="metric-card">
                <div class="metric-header">
                    <span class="metric-title">Taxa de Acerto</span>
                    <span class="metric-icon">üéØ</span>
                </div>
                <div class="metric-value" id="winRate">0%</div>
                <div class="metric-change neutral" id="winRateChange">
                    <span>‚Üó</span> Calculando...
                </div>
            </div>

            <div class="metric-card">
                <div class="metric-header">
                    <span class="metric-title">Trades Hoje</span>
                    <span class="metric-icon">‚ö°</span>
                </div>
                <div class="metric-value" id="tradesCount">0</div>
                <div class="metric-change neutral" id="tradesChange">
                    <span>‚Üó</span> 0 wins, 0 losses
                </div>
            </div>

            <div class="metric-card">
                <div class="metric-header">
                    <span class="metric-title">ML Status</span>
                    <span class="metric-icon">ü§ñ</span>
                </div>
                <div class="metric-value" id="mlStatusValue">Carregando</div>
                <div class="metric-change neutral" id="mlStatusChange">
                    <span>‚Üó</span> <span id="mlStatusDisplay">Inicializando</span>
                </div>
            </div>

            <div class="metric-card">
                <div class="metric-header">
                    <span class="metric-title">Martingale Status</span>
                    <span class="metric-icon">üé∞</span>
                </div>
                <div class="metric-value" id="martingaleStatusValue">Pronto</div>
                <div class="metric-change neutral" id="martingaleStatusChange">
                    <span>‚Üó</span> <span id="martingaleStatusDisplay">Aguardando</span>
                </div>
            </div>
        </div>

        <!-- Painel de Controle -->
        <div class="control-panel">
            <h3 style="color: #00d4ff; margin-bottom: 20px;">‚ö° Trading com IA ML Real + Martingale Inteligente</h3>
            
            <div class="control-grid">
                <div class="control-item">
                    <label>S√≠mbolo:</label>
                    <select id="symbolSelect">
                        <optgroup label="üìä Volatility Indices">
                            <option value="R_10">Volatility 10 Index</option>
                            <option value="R_25">Volatility 25 Index</option>
                            <option value="R_50" selected>Volatility 50 Index</option>
                            <option value="R_75">Volatility 75 Index</option>
                            <option value="R_100">Volatility 100 Index</option>
                        </optgroup>
                        
                        <optgroup label="‚ö° Volatility Indices (1s)">
                            <option value="1HZ10V">Volatility 10 (1s) Index</option>
                            <option value="1HZ25V">Volatility 25 (1s) Index</option>
                            <option value="1HZ50V">Volatility 50 (1s) Index</option>
                            <option value="1HZ75V">Volatility 75 (1s) Index</option>
                            <option value="1HZ100V">Volatility 100 (1s) Index</option>
                            <option value="1HZ150V">Volatility 150 (1s) Index</option>
                            <option value="1HZ200V">Volatility 200 (1s) Index</option>
                            <option value="1HZ250V">Volatility 250 (1s) Index</option>
                        </optgroup>
                        
                        <optgroup label="ü¶ò Jump Indices">
                            <option value="JD10">Jump 10 Index</option>
                            <option value="JD25">Jump 25 Index</option>
                            <option value="JD50">Jump 50 Index</option>
                            <option value="JD75">Jump 75 Index</option>
                            <option value="JD100">Jump 100 Index</option>
                        </optgroup>
                        
                        <optgroup label="üìä Step Indices">
                            <option value="STPRAN">Step 100 Index</option>
                            <option value="STPRAN200">Step 200 Index</option>
                            <option value="STPRAN500">Step 500 Index</option>
                        </optgroup>
                        
                        <optgroup label="ÔøΩÔøΩ Market Indices">
                            <option value="RDBEAR">Bear Market Index</option>
                            <option value="RDBULL">Bull Market Index</option>
                        </optgroup>
                        
                        <optgroup label="üí• Crash/Boom Indices">
                            <option value="CRASH300">Crash 300 Index</option>
                            <option value="CRASH500">Crash 500 Index</option>
                            <option value="CRASH600">Crash 600 Index</option>
                            <option value="CRASH900">Crash 900 Index</option>
                            <option value="CRASH1000">Crash 1000 Index</option>
                            <option value="BOOM300">Boom 300 Index</option>
                            <option value="BOOM500">Boom 500 Index</option>
                            <option value="BOOM600">Boom 600 Index</option>
                            <option value="BOOM900">Boom 900 Index</option>
                            <option value="BOOM1000">Boom 1000 Index</option>
                        </optgroup>
                    </select>
                </div>
                
                <div class="control-item" id="stakeControl">
                    <label>Valor da Aposta (USD):</label>
                    <input type="number" id="stakeAmount" value="1" min="0.35" max="2000" step="0.01">
                </div>
                
                <div class="control-item" id="durationTypeControl">
                    <label>Tipo de Dura√ß√£o:</label>
                    <select id="durationType" onchange="updateDurationOptions()">
                        <option value="t">Ticks</option>
                        <option value="m">Minutos</option>
                    </select>
                </div>
                
                <div class="control-item" id="durationControl">
                    <label>Dura√ß√£o:</label>
                    <select id="duration">
                        <!-- Ser√° preenchido dinamicamente -->
                    </select>
                </div>

                <div class="control-item">
                    <label>Modo Trading:</label>
                    <select id="tradingMode">
                        <option value="manual">Manual</option>
                        <option value="auto">Autom√°tico</option>
                        <option value="ai">IA ML Real</option>
                    </select>
                </div>
            </div>

            <!-- üìä INDICADOR DE ORDEM ATIVA -->
            <div class="active-order-indicator" id="activeOrderIndicator">
                <div class="active-order-title">
                    üìä Ordem Ativa: <span id="activeOrderDirection">-</span>
                </div>
                <div class="active-order-details">
                    üí∞ Valor: $<span id="activeOrderStake">0.00</span> | 
                    üìà S√≠mbolo: <span id="activeOrderSymbol">-</span> | 
                    ‚è±Ô∏è Dura√ß√£o: <span id="activeOrderDuration">-</span>
                </div>
                <div style="font-size: 0.8rem; margin-top: 5px; opacity: 0.8;">
                    üïí Iniciado: <span id="activeOrderTime">-</span>
                </div>
            </div>

            <!-- üé∞ MARTINGALE INTELIGENTE MELHORADO -->
            <div class="martingale-info" id="martingaleInfo">
                <div class="martingale-level">
                    üé∞ Martingale Inteligente N√≠vel: <span id="martingaleLevelDisplay">0</span>/8
                </div>
                <div class="next-stake">
                    üí∞ Pr√≥xima Aposta: $<span id="nextStakeDisplay">1.00</span>
                </div>
                <div style="font-size: 0.9rem; margin-top: 5px; opacity: 0.8;">
                    üìä Stake Base: $<span id="baseStakeDisplay">1.00</span> | 
                    üîÑ Reset autom√°tico ap√≥s WIN | üß† IA ML controla timing
                </div>
                
                <div class="martingale-status ready" id="martingaleStatusBar">
                    ‚úÖ Pronto para operar - Aguardando an√°lise da IA ML
                </div>
                
                <div class="martingale-controls">
                    <button class="martingale-toggle" onclick="toggleMartingale()" id="martingaleToggle">
                        üé∞ Martingale: ON
                    </button>
                    <button class="martingale-toggle" onclick="resetMartingaleManual()" id="resetMartingale">
                        üîÑ Reset Manual
                    </button>
                    <div style="font-size: 0.8rem; opacity: 0.7;">
                        Sistema Anti-Loop: ON
                    </div>
                </div>
            </div>
            
            <div class="trade-buttons">
                <button class="trade-btn call" onclick="placeTrade('CALL')" id="callBtn" disabled>
                    üìà RISE (Higher)
                </button>
                <button class="trade-btn put" onclick="placeTrade('PUT')" id="putBtn" disabled>
                    üìâ FALL (Lower)
                </button>
                <button class="trade-btn stop" onclick="toggleAutoTrading()" id="autoBtn" disabled>
                    ü§ñ Iniciar Auto
                </button>
            </div>
        </div>

        <!-- Tabela de Trades -->
        <div class="trades-table">
            <div class="table-header">
                <h3 style="color: #00d4ff;">üéØ Hist√≥rico de Trades com IA ML</h3>
                <div style="font-size: 0.9rem; opacity: 0.7;">
                    Sistema Machine Learning + Martingale Inteligente
                </div>
            </div>

            <div class="trades-grid">
                <div>ID</div>
                <div>Hor√°rio</div>
                <div>S√≠mbolo</div>
                <div>Tipo</div>
                <div>Valor</div>
                <div>Dura√ß√£o</div>
                <div>Entry</div>
                <div>Status</div>
                <div>P&L</div>
            </div>

            <div id="tradesTableBody">
                <div style="text-align: center; padding: 20px; opacity: 0.7;">
                    ü§ñ Nenhum trade ML executado ainda...
                </div>
            </div>
        </div>
    </div>

    <!-- Notifications -->
    <div class="notification" id="notification"></div>

    <script>
        // ==============================================
        // CONFIGURA√á√ïES E CONSTANTES - ML REAL
        // ==============================================
        
        const CONFIG = {
            WS_URL: 'wss://ws.derivws.com/websockets/v3?app_id=1089',
            AI_API_URL: window.location.origin, // API Python ML
            MIN_STAKE: 0.35,
            MAX_STAKE: 2000,
            DEFAULT_SYMBOL: 'R_50',
            AUTO_TRADE_DELAY: {
                MIN: 30000,
                MAX: 120000
            },
            MARTINGALE_DELAYS: {
                COOLING_PERIOD: 15000,
                ANALYSIS_WAIT: 10000,
                MIN_BETWEEN_TRADES: 8000
            },
            AI_DURATION_LIMITS: {
                t: { min: 1, max: 10 },
                m: { min: 1, max: 5 }
            },
            ML_CONFIG: {
                MIN_SAMPLES_FOR_TRAINING: 50,
                AUTO_RETRAIN_THRESHOLD: 100,
                CONFIDENCE_THRESHOLD: 75,
                HEALTH_CHECK_INTERVAL: 60000
            }
        };

        const DURATION_OPTIONS = {
            t: Array.from({length: 10}, (_, i) => ({ value: i + 1, label: `${i + 1} tick${i > 0 ? 's' : ''}` })),
            m: [
                { value: 1, label: '1 min' },
                { value: 2, label: '2 mins' },
                { value: 3, label: '3 mins' },
                { value: 4, label: '4 mins' },
                { value: 5, label: '5 mins' },
                { value: 10, label: '10 mins' },
                { value: 15, label: '15 mins' },
                { value: 30, label: '30 mins' },
                { value: 60, label: '1 hora' }
            ]
        };

        // ==============================================
        // VARI√ÅVEIS GLOBAIS ML REAL
        // ==============================================
        
        let ws = null;
        let apiToken = '';
        let accountInfo = {};
        let isConnected = false;
        let isAutoTrading = false;
        let isAIConnected = false;
        let isAIModeActive = false;

        // ü§ñ CONTROLES ML
        let isAIDurationActive = false;
        let isAIManagementActive = false;
        let mlModelsLoaded = false;
        let mlTrainingData = [];

        // üìä CONTROLE DE ORDEM √öNICA
        let hasActiveOrder = false;
        let activeOrderInfo = null;
        let contractSubscriptions = new Map();

        // üé∞ SISTEMA MARTINGALE INTELIGENTE
        let martingaleState = {
            level: 0,
            baseStake: 1,
            maxLevel: 8,
            isActive: true,
            sequence: [],
            multiplier: 2,
            isInCoolingPeriod: false,
            isWaitingForAnalysis: false,
            lastTradeTime: 0,
            needsAnalysisAfterLoss: false,
            coolingTimeout: null,
            analysisTimeout: null
        };

        let currentPrice = 0;
        let trades = [];
        let sessionStats = {
            totalTrades: 0,
            wonTrades: 0,
            lostTrades: 0,
            totalPnL: 0,
            startBalance: 0
        };
        let openContracts = new Map();

        // ü§ñ DADOS IA ML
        let aiData = {
            lastAnalysis: null,
            lastSignal: null,
            confidence: 0,
            riskLevel: 'medium',
            optimalDuration: null,
            managementDecision: null,
            lastDurationUpdate: null,
            mlStats: null,
            technicalIndicators: null,
            modelAccuracy: {}
        };

        let orderLock = false;
        let orderTimeout = null;

        // ==============================================
        // ü§ñ FUN√á√ïES ML REAL - INTEGRA√á√ÉO AVAN√áADA
        // ==============================================

        async function connectToAI() {
            try {
                console.log('ü§ñ Conectando √† IA ML Real...');
                
                const response = await fetch(`${CONFIG.AI_API_URL}/api/health`);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('‚úÖ IA ML conectada:', data);
                    
                    isAIConnected = true;
                    mlModelsLoaded = data.ml_status?.models_available?.length > 0;
                    
                    updateStatus('aiStatus', 'online');
                    document.getElementById('aiStatusText').textContent = 'ML Real Conectado';
                    
                    // Atualizar interface com informa√ß√µes ML
                    if (data.ml_status) {
                        updateMLDisplay(data.ml_status);
                        aiData.mlStats = data.ml_status;
                    }
                    
                    enableAIControls(true);
                    
                    // Verificar sa√∫de ML periodicamente
                    setInterval(checkMLHealth, CONFIG.ML_CONFIG.HEALTH_CHECK_INTERVAL);
                    
                    showNotification('ü§ñ IA com Machine Learning Real conectada!', 'success');
                    return true;
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
                
            } catch (error) {
                console.error('‚ùå Erro ao conectar IA ML:', error);
                isAIConnected = false;
                updateStatus('aiStatus', 'error');
                document.getElementById('aiStatusText').textContent = 'Erro ML';
                document.getElementById('connectionMethod').textContent = 'Falha ML API';
                
                showNotification('‚ö†Ô∏è Erro ao conectar IA ML - modo b√°sico', 'error');
                return false;
            }
        }

        function enableAIControls(enabled) {
            const aiButtons = [
                'aiAnalyzeBtn', 'aiSignalBtn', 'aiRiskBtn', 'aiModeBtn', 
                'aiDurationBtn', 'aiManagementBtn', 'aiIndicatorsBtn', 
                'aiTrainBtn', 'aiStatsBtn'
            ];
            aiButtons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) btn.disabled = !enabled;
            });
        }

        async function getMLStatistics() {
            if (!isAIConnected) return;

            try {
                showAIResponse('üìä Obtendo estat√≠sticas ML...');
                
                const response = await fetch(`${CONFIG.AI_API_URL}/api/ml/stats`);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const mlStats = await response.json();
                updateMLDisplay(mlStats);
                updateMLStatsPanel(mlStats);
                aiData.mlStats = mlStats;
                
                showAIResponse('üìä Estat√≠sticas ML atualizadas');
                
            } catch (error) {
                console.error('‚ùå Erro ao obter estat√≠sticas ML:', error);
                showAIResponse('‚ùå Erro ao obter estat√≠sticas ML');
            }
        }

        function updateMLDisplay(mlStats) {
            // Atualizar display principal
            const aiStatusText = document.getElementById('aiStatusText');
            const mlStatusValue = document.getElementById('mlStatusValue');
            const mlStatusDisplay = document.getElementById('mlStatusDisplay');
            
            if (mlStats.models_trained) {
                aiStatusText.textContent = `ML Treinado (${mlStats.training_samples} samples)`;
                mlStatusValue.textContent = 'Treinado';
                mlStatusDisplay.textContent = `${mlStats.training_samples} samples`;
            } else {
                aiStatusText.textContent = `ML Coletando (${mlStats.training_samples}/${CONFIG.ML_CONFIG.MIN_SAMPLES_FOR_TRAINING})`;
                mlStatusValue.textContent = 'Coletando';
                mlStatusDisplay.textContent = 'Dados insuficientes';
            }

            // Atualizar connection method com detalhes ML
            const connectionMethod = document.getElementById('connectionMethod');
            const modelsText = mlStats.models_available ? `${mlStats.models_available.length} modelos` : 'ML b√°sico';
            connectionMethod.textContent = `Python ML API (${modelsText})`;

            // Atualizar status do API Key com accuracy
            const apiKeyStatus = document.getElementById('apiKeyStatus');
            if (mlStats.model_accuracy && Object.keys(mlStats.model_accuracy).length > 0) {
                const avgAccuracy = Object.values(mlStats.model_accuracy).reduce((a, b) => a + b, 0) / Object.values(mlStats.model_accuracy).length;
                apiKeyStatus.textContent = `ML Accuracy: ${(avgAccuracy * 100).toFixed(1)}%`;
            } else {
                apiKeyStatus.textContent = 'ML Treinando';
            }

            // Atualizar m√©tricas ML
            const mlStatusChange = document.getElementById('mlStatusChange');
            if (mlStats.models_trained) {
                mlStatusChange.innerHTML = '<span>‚úÖ</span> Modelos ativos';
                mlStatusChange.className = 'metric-change positive';
            } else {
                mlStatusChange.innerHTML = '<span>‚è≥</span> Coletando dados';
                mlStatusChange.className = 'metric-change neutral';
            }
        }

        function updateMLStatsPanel(mlStats) {
            const panel = document.getElementById('mlStatsPanel');
            const grid = document.getElementById('mlStatsGrid');
            
            if (!mlStats || !mlStats.ml_enabled) {
                panel.classList.remove('show');
                return;
            }

            panel.classList.add('show');
            
            // Criar estat√≠sticas detalhadas
            const stats = [
                { label: 'Modelos Carregados', value: mlStats.models_available?.length || 0 },
                { label: 'Modelos Treinados', value: mlStats.models_trained ? 'Sim' : 'N√£o' },
                { label: 'Samples de Treino', value: mlStats.training_samples || 0 },
                { label: '√öltima Predi√ß√£o', value: mlStats.last_prediction?.direction || 'N/A' },
                { label: 'Regime de Mercado', value: mlStats.market_regime || 'neutral' },
                { label: 'Regime Volatilidade', value: mlStats.volatility_regime || 'normal' }
            ];

            // Adicionar accuracies dos modelos
            if (mlStats.model_accuracy) {
                Object.entries(mlStats.model_accuracy).forEach(([model, accuracy]) => {
                    stats.push({
                        label: `${model} Accuracy`,
                        value: `${(accuracy * 100).toFixed(1)}%`
                    });
                });
            }

            grid.innerHTML = stats.map(stat => `
                <div class="ml-stat-item">
                    <strong>${stat.label}:</strong> ${stat.value}
                </div>
            `).join('');
        }

        async function trainMLModels() {
            if (!isAIConnected) {
                showNotification('IA n√£o conectada', 'error');
                return;
            }

            try {
                document.getElementById('aiTrainBtn').disabled = true;
                showAIResponse('üéì Iniciando treinamento ML...');
                
                const response = await fetch(`${CONFIG.AI_API_URL}/api/ml/train`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const result = await response.json();
                
                if (result.status === 'success') {
                    showAIResponse('‚úÖ Modelos ML treinados com sucesso! Performance atualizada.');
                    showNotification('üéì ML treinado com sucesso!', 'success');
                    await getMLStatistics();
                    mlModelsLoaded = true;
                } else {
                    showAIResponse(`‚ö†Ô∏è ${result.message}`);
                    showNotification(result.message, 'warning');
                }
                
            } catch (error) {
                console.error('‚ùå Erro no treinamento ML:', error);
                showAIResponse('‚ùå Erro no treinamento ML');
                showNotification('Erro ao treinar ML', 'error');
            } finally {
                document.getElementById('aiTrainBtn').disabled = false;
            }
        }

        async function getTechnicalIndicators() {
            if (!isAIConnected) return;

            try {
                showAIResponse('üìà Calculando indicadores t√©cnicos...');
                
                const response = await fetch(`${CONFIG.AI_API_URL}/api/ml/indicators`);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const data = await response.json();
                
                if (data.available && data.indicators) {
                    const indicators = data.indicators;
                    aiData.technicalIndicators = indicators;
                    
                    let indicatorText = 'üìà Indicadores T√©cnicos: ';
                    
                    if (indicators.rsi !== undefined) {
                        const rsiStatus = indicators.rsi > 70 ? 'üî¥ Sobrecompra' : indicators.rsi < 30 ? 'üü¢ Sobrevenda' : 'üü° Neutro';
                        indicatorText += `RSI ${indicators.rsi.toFixed(1)} ${rsiStatus} | `;
                    }
                    
                    if (indicators.macd !== undefined) {
                        const macdStatus = indicators.macd > 0 ? 'üìà Bullish' : 'üìâ Bearish';
                        indicatorText += `MACD ${indicators.macd.toFixed(3)} ${macdStatus} | `;
                    }
                    
                    if (indicators.bb_position !== undefined) {
                        const bbPos = (indicators.bb_position * 100).toFixed(0);
                        const bbStatus = bbPos > 80 ? 'üî¥ Topo BB' : bbPos < 20 ? 'üü¢ Base BB' : 'üü° Meio BB';
                        indicatorText += `BB ${bbPos}% ${bbStatus} | `;
                    }
                    
                    if (indicators.volatility !== undefined) {
                        const volStatus = indicators.volatility > 50 ? 'üåä Alta Vol' : 'üò¥ Baixa Vol';
                        indicatorText += `Vol ${indicators.volatility.toFixed(1)}% ${volStatus}`;
                    }
                    
                    if (indicators.trend_strength !== undefined) {
                        const trendStatus = indicators.trend_strength > 1 ? 'üìà Trend Up' : 
                                          indicators.trend_strength < -1 ? 'üìâ Trend Down' : '‚û°Ô∏è Lateral';
                        indicatorText += ` | ${trendStatus}`;
                    }
                    
                    showAIResponse(indicatorText);
                } else {
                    showAIResponse('üìä Coletando dados para indicadores t√©cnicos... (m√≠nimo 20 ticks necess√°rios)');
                }
                
            } catch (error) {
                console.error('‚ùå Erro ao obter indicadores:', error);
                showAIResponse('‚ùå Erro ao calcular indicadores t√©cnicos');
            }
        }

        // Modificar as fun√ß√µes existentes para usar ML real
        async function getAIAnalysis() {
            if (!isAIConnected) {
                showNotification('IA n√£o conectada', 'error');
                return;
            }

            try {
                document.getElementById('aiAnalyzeBtn').disabled = true;
                showAIResponse('ü§ñ Executando an√°lise ML completa...');

                const symbol = document.getElementById('symbolSelect').value;
                const marketData = {
                    symbol: symbol,
                    currentPrice: currentPrice,
                    timestamp: new Date().toISOString(),
                    trades: trades.slice(-10),
                    balance: sessionStats.startBalance,
                    winRate: sessionStats.totalTrades > 0 ? (sessionStats.wonTrades / sessionStats.totalTrades) * 100 : 0,
                    volatility: calculateVolatility(),
                    marketCondition: analyzeMarketCondition(),
                    martingaleLevel: martingaleState.level,
                    isAfterLoss: martingaleState.needsAnalysisAfterLoss,
                    totalTrades: sessionStats.totalTrades
                };

                const response = await fetch(`${CONFIG.AI_API_URL}/api/analyze`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(marketData)
                });
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const analysisResult = await response.json();
                aiData.lastAnalysis = analysisResult;
                
                // Mostrar resultado detalhado
                let message = analysisResult.message || 'An√°lise ML conclu√≠da';
                
                if (analysisResult.ml_enabled) {
                    message += ` | üéØ Confian√ßa: ${(analysisResult.confidence || 75).toFixed(1)}%`;
                    
                    if (analysisResult.technical_indicators) {
                        const indicators = analysisResult.technical_indicators;
                        if (indicators.rsi !== undefined) message += ` | RSI: ${indicators.rsi.toFixed(1)}`;
                        if (indicators.volatility !== undefined) message += ` | Vol: ${indicators.volatility.toFixed(1)}%`;
                        if (indicators.bb_position !== undefined) message += ` | BB: ${(indicators.bb_position * 100).toFixed(0)}%`;
                    }
                    
                    if (analysisResult.market_regime) {
                        message += ` | Regime: ${analysisResult.market_regime}`;
                    }
                    
                    if (analysisResult.processing_time_ms) {
                        message += ` | ‚ö° ${analysisResult.processing_time_ms.toFixed(0)}ms`;
                    }

                    if (analysisResult.ml_models_count) {
                        message += ` | ü§ñ ${analysisResult.ml_models_count} modelos`;
                    }
                }
                
                showAIResponse(message);
                
                // Notificar resultado para aprendizado
                notifyMLAnalysis(analysisResult);
                
            } catch (error) {
                console.error('‚ùå Erro na an√°lise IA:', error);
                showAIResponse('‚ùå Erro na an√°lise ML - usando fallback b√°sico');
                showNotification('Erro na an√°lise ML', 'error');
            } finally {
                document.getElementById('aiAnalyzeBtn').disabled = false;
            }
        }

        async function getAITradingSignal() {
            if (!isAIConnected) {
                showNotification('IA n√£o conectada', 'error');
                return;
            }

            try {
                document.getElementById('aiSignalBtn').disabled = true;
                showAIResponse('üéØ Gerando sinal ML com m√∫ltiplos modelos...');

                const symbol = document.getElementById('symbolSelect').value;
                const requestData = {
                    symbol: symbol,
                    currentPrice: currentPrice,
                    accountBalance: sessionStats.startBalance,
                    winRate: sessionStats.totalTrades > 0 ? (sessionStats.wonTrades / sessionStats.totalTrades) * 100 : 0,
                    recentTrades: trades.slice(-5),
                    timestamp: new Date().toISOString(),
                    volatility: calculateVolatility(),
                    marketCondition: analyzeMarketCondition(),
                    martingaleLevel: martingaleState.level,
                    isAfterLoss: martingaleState.needsAnalysisAfterLoss,
                    totalTrades: sessionStats.totalTrades
                };

                const response = await fetch(`${CONFIG.AI_API_URL}/api/signal`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                });
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const signalResult = await response.json();
                aiData.lastSignal = signalResult;
                
                const direction = signalResult.direction || 'CALL';
                const confidence = signalResult.confidence || 70;
                
                let message = `üéØ Sinal ML Ensemble: ${direction}`;
                
                if (signalResult.ml_enabled) {
                    message += ` | üéØ ${confidence.toFixed(1)}%`;
                    
                    if (signalResult.risk_adjusted_confidence !== undefined && 
                        Math.abs(signalResult.risk_adjusted_confidence - confidence) > 2) {
                        message += ` (Risco Adj: ${signalResult.risk_adjusted_confidence.toFixed(1)}%)`;
                    }
                    
                    if (signalResult.technical_score !== undefined) {
                        message += ` | Tech Score: ${signalResult.technical_score.toFixed(0)}%`;
                    }
                    
                    if (signalResult.timeframe) {
                        message += ` | ‚è±Ô∏è ${signalResult.timeframe}`;
                    }
                    
                    if (signalResult.market_regime && signalResult.market_regime !== 'neutral') {
                        message += ` | ${signalResult.market_regime}`;
                    }

                    if (signalResult.ml_models_used) {
                        message += ` | ü§ñ ${signalResult.ml_models_used} modelos`;
                    }
                }
                
                if (signalResult.reasoning && signalResult.reasoning.length < 100) {
                    message += ` | ${signalResult.reasoning}`;
                }
                
                showAIResponse(message);
                
                // Auto-executar se modo IA ativo e confian√ßa alta
                if (isAIModeActive && confidence > CONFIG.ML_CONFIG.CONFIDENCE_THRESHOLD && canPlaceNewOrder()) {
                    setTimeout(() => {
                        placeTrade(direction);
                        showNotification(`ü§ñ Trade ML executado: ${direction} (${confidence.toFixed(1)}%)`, 'success');
                    }, 2000);
                }
                
            } catch (error) {
                console.error('‚ùå Erro no sinal IA:', error);
                showAIResponse('‚ùå Erro no sinal ML - usando fallback b√°sico');
                showNotification('Erro no sinal ML', 'error');
            } finally {
                document.getElementById('aiSignalBtn').disabled = false;
            }
        }

        async function getAIRiskAssessment() {
            if (!isAIConnected) {
                showNotification('IA n√£o conectada', 'error');
                return;
            }

            try {
                document.getElementById('aiRiskBtn').disabled = true;
                showAIResponse('‚ö†Ô∏è Executando avalia√ß√£o ML multifatorial de risco...');

                const riskData = {
                    currentBalance: sessionStats.startBalance,
                    todayPnL: sessionStats.totalPnL,
                    martingaleLevel: martingaleState.level,
                    recentTrades: trades.slice(-5),
                    winRate: sessionStats.totalTrades > 0 ? (sessionStats.wonTrades / sessionStats.totalTrades) * 100 : 0,
                    totalTrades: sessionStats.totalTrades,
                    timestamp: new Date().toISOString(),
                    isInCoolingPeriod: martingaleState.isInCoolingPeriod,
                    needsAnalysisAfterLoss: martingaleState.needsAnalysisAfterLoss
                };

                const response = await fetch(`${CONFIG.AI_API_URL}/api/risk`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(riskData)
                });
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const riskResult = await response.json();
                aiData.riskLevel = riskResult.level || 'medium';
                
                let message = riskResult.message || `Risco ${aiData.riskLevel} detectado`;
                
                if (riskResult.ml_enabled && riskResult.risk_breakdown) {
                    const breakdown = riskResult.risk_breakdown;
                    message += ` | Breakdown: `;
                    message += `üé∞ M:${breakdown.martingale_risk.toFixed(0)}`;
                    message += ` üí∞ P:${breakdown.pnl_risk.toFixed(0)}`;
                    message += ` üéØ Perf:${breakdown.performance_risk.toFixed(0)}`;
                    
                    if (breakdown.technical_risk > 20) {
                        message += ` üìà Tech:${breakdown.technical_risk.toFixed(0)}`;
                    }
                    
                    if (breakdown.volatility_risk > 20) {
                        message += ` üåä Vol:${breakdown.volatility_risk.toFixed(0)}`;
                    }
                }
                
                if (riskResult.recommendation) {
                    message += ` | üí° ${riskResult.recommendation}`;
                }
                
                if (riskResult.specific_recommendations && riskResult.specific_recommendations.length > 0) {
                    message += ` | ‚ö†Ô∏è ${riskResult.specific_recommendations[0]}`;
                }

                if (riskResult.processing_time_ms) {
                    message += ` | ‚ö° ${riskResult.processing_time_ms.toFixed(0)}ms`;
                }
                
                showAIResponse(message);
                
                // Mostrar notifica√ß√£o baseada no n√≠vel de risco
                if (riskResult.level === 'high') {
                    showNotification('üî¥ RISCO ALTO detectado pelo ML!', 'error');
                } else if (riskResult.level === 'medium') {
                    showNotification('üü° Risco moderado - cautela recomendada', 'warning');
                } else {
                    showNotification('üü¢ Risco baixo - condi√ß√µes normais', 'success');
                }
                
            } catch (error) {
                console.error('‚ùå Erro na avalia√ß√£o de risco:', error);
                showAIResponse('‚ùå Erro na avalia√ß√£o ML de risco');
                showNotification('Erro na avalia√ß√£o de risco ML', 'error');
            } finally {
                document.getElementById('aiRiskBtn').disabled = false;
            }
        }

        // Fun√ß√£o para verificar periodicamente status ML e retreinar se necess√°rio
        async function checkMLHealth() {
            if (!isAIConnected) return;

            try {
                await getMLStatistics();
                
                // Auto-treinar se temos dados suficientes mas modelos n√£o treinados
                if (aiData.mlStats) {
                    const stats = aiData.mlStats;
                    
                    if (stats.training_samples >= CONFIG.ML_CONFIG.MIN_SAMPLES_FOR_TRAINING && 
                        !stats.models_trained) {
                        console.log('üéì Auto-treinamento ML iniciado...');
                        await trainMLModels();
                    }
                }
                
            } catch (error) {
                console.error('‚ùå Erro no check ML:', error);
            }
        }

        // Fun√ß√£o para notificar resultado de an√°lise para aprendizado ML
        function notifyMLAnalysis(analysisResult) {
            console.log('üìä An√°lise ML registrada:', analysisResult);
            
            // Adicionar √† hist√≥ria de an√°lises para melhorar futuras predi√ß√µes
            if (analysisResult.confidence && analysisResult.direction) {
                mlTrainingData.push({
                    timestamp: new Date().toISOString(),
                    analysis: analysisResult,
                    context: {
                        symbol: document.getElementById('symbolSelect').value,
                        price: currentPrice,
                        martingale_level: martingaleState.level
                    }
                });
                
                // Manter apenas as √∫ltimas 100 an√°lises
                if (mlTrainingData.length > 100) {
                    mlTrainingData = mlTrainingData.slice(-100);
                }
            }
        }

        // Fun√ß√£o melhorada para notificar resultado do trade para ML
        window.notifyMLTrade = async function(tradeData) {
            if (!isAIConnected) return;

            try {
                // Extrair features do contexto atual para aprendizado
                const features = {
                    direction: tradeData.direction,
                    success: tradeData.pnl > 0,
                    pnl: tradeData.pnl,
                    martingaleLevel: tradeData.martingaleLevel || martingaleState.level,
                    timestamp: new Date().toISOString(),
                    symbol: tradeData.symbol,
                    volatility: calculateVolatility(),
                    currentPrice: currentPrice,
                    winRate: sessionStats.totalTrades > 0 ? (sessionStats.wonTrades / sessionStats.totalTrades) * 100 : 0,
                    
                    // Features normalizadas para ML
                    features: [
                        // Resultado normalizado
                        tradeData.pnl > 0 ? 1 : 0,
                        // P&L normalizado (-1 a 1)
                        Math.max(-1, Math.min(1, (tradeData.pnl || 0) / 100)),
                        // Martingale level normalizado (0 a 1)
                        (martingaleState.level || 0) / 10,
                        // Win rate normalizado (0 a 1)
                        ((sessionStats.wonTrades / Math.max(sessionStats.totalTrades, 1)) || 0.5),
                        // Volatilidade normalizada (0 a 1)
                        (calculateVolatility() || 50) / 100,
                        // Hora do dia normalizada (0 a 1)
                        new Date().getHours() / 24,
                        // Pre√ßo normalizado (relativo)
                        ((currentPrice || 1000) - 1000) / 1000,
                        // Dire√ß√£o (0 = PUT, 1 = CALL)
                        tradeData.direction === 'CALL' ? 1 : 0,
                        // Se foi ap√≥s loss (0 ou 1)
                        martingaleState.needsAnalysisAfterLoss ? 1 : 0,
                        // Total de trades normalizado
                        Math.min(sessionStats.totalTrades / 100, 1)
                    ]
                };

                const response = await fetch(`${CONFIG.AI_API_URL}/api/ml/learn`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(features)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('‚úÖ ML aprendeu com trade:', result.ml_stats);
                    
                    // Atualizar display se recebemos estat√≠sticas
                    if (result.ml_stats) {
                        updateMLDisplay(result.ml_stats);
                        aiData.mlStats = result.ml_stats;
                    }

                    // Mostrar feedback de aprendizado
                    if (result.ml_stats && result.ml_stats.training_samples % 10 === 0) {
                        showNotification(`üéì ML aprendeu: ${result.ml_stats.training_samples} samples`, 'success');
                    }
                } else {
                    console.log('‚ö†Ô∏è ML n√£o conseguiu processar trade');
                }
                
            } catch (error) {
                console.error('‚ùå Erro ao notificar ML:', error);
            }
        };

        function showAIResponse(message) {
            const responseDiv = document.getElementById('aiResponse');
            const responseText = document.getElementById('aiResponseText');
            
            responseText.textContent = message;
            responseDiv.style.display = 'block';
            
            // Auto-hide ap√≥s 30 segundos
            setTimeout(() => {
                responseDiv.style.display = 'none';
            }, 30000);

            console.log('ü§ñ IA Response:', message);
        }

        // ==============================================
        // SISTEMA MARTINGALE INTELIGENTE ANTI-LOOP
        // ==============================================

        function initializeMartingale() {
            martingaleState.baseStake = parseFloat(document.getElementById('stakeAmount').value) || 1;
            updateMartingaleDisplay();
            updateMartingaleStatus('ready', '‚úÖ Pronto para operar - Aguardando an√°lise da IA ML');
            console.log('üéØ Martingale Inteligente inicializado com stake base:', martingaleState.baseStake);
        }

        function resetMartingale() {
            console.log('üîÑ RESET MARTINGALE - Vit√≥ria detectada!');
            
            const previousLevel = martingaleState.level;
            
            if (martingaleState.coolingTimeout) {
                clearTimeout(martingaleState.coolingTimeout);
                martingaleState.coolingTimeout = null;
            }
            if (martingaleState.analysisTimeout) {
                clearTimeout(martingaleState.analysisTimeout);
                martingaleState.analysisTimeout = null;
            }
            
            martingaleState.level = 0;
            martingaleState.sequence = [];
            martingaleState.isInCoolingPeriod = false;
            martingaleState.isWaitingForAnalysis = false;
            martingaleState.needsAnalysisAfterLoss = false;
            
            const stakeInput = document.getElementById('stakeAmount');
            stakeInput.value = martingaleState.baseStake.toFixed(2);
            
            updateMartingaleDisplay();
            updateMartingaleStatus('ready', '‚úÖ Pronto - Martingale resetado ap√≥s WIN');
            
            if (previousLevel > 0) {
                showNotification(
                    `üèÜ WIN! Martingale resetado (N√≠vel ${previousLevel} ‚Üí 0)`,
                    'success'
                );
                
                console.log(`‚úÖ Martingale resetado: N√≠vel ${previousLevel} ‚Üí 0`);
                console.log(`üí∞ Stake resetado: $${stakeInput.value}`);
            }
        }

        function applyMartingale() {
            console.log('üìà APLICANDO MARTINGALE INTELIGENTE - Loss detectado!');
            
            martingaleState.level++;
            
            if (martingaleState.level > martingaleState.maxLevel) {
                console.log(`‚ö†Ô∏è Limite m√°ximo de Martingale atingido: ${martingaleState.maxLevel}`);
                showNotification(
                    `üõë Limite de Martingale atingido (${martingaleState.maxLevel}). Resetando...`,
                    'error'
                );
                resetMartingale();
                return;
            }
            
            const newStake = martingaleState.baseStake * Math.pow(2, martingaleState.level);
            
            if (newStake > CONFIG.MAX_STAKE) {
                console.log(`‚ö†Ô∏è Stake calculado (${newStake}) excede limite m√°ximo (${CONFIG.MAX_STAKE})`);
                showNotification(
                    `üõë Stake muito alto para continuar Martingale. Resetando...`,
                    'error'
                );
                resetMartingale();
                return;
            }
            
            const stakeInput = document.getElementById('stakeAmount');
            stakeInput.value = newStake.toFixed(2);
            
            martingaleState.sequence.push({
                level: martingaleState.level,
                stake: newStake,
                timestamp: new Date()
            });
            
            martingaleState.isInCoolingPeriod = true;
            martingaleState.needsAnalysisAfterLoss = true;
            martingaleState.lastTradeTime = Date.now();
            
            updateMartingaleDisplay();
            updateMartingaleStatus('cooling', `‚ùÑÔ∏è Cooling Period - Aguardando ${CONFIG.MARTINGALE_DELAYS.COOLING_PERIOD/1000}s antes de pr√≥ximo trade`);
            
            showNotification(
                `üìà Martingale N√≠vel ${martingaleState.level}: $${newStake.toFixed(2)} - AGUARDANDO AN√ÅLISE ML`,
                'warning'
            );
            
            console.log(`üìà Martingale aplicado: N√≠vel ${martingaleState.level}, Stake: $${newStake.toFixed(2)}`);
            console.log(`‚ùÑÔ∏è Cooling period ativado - Sistema aguardar√° an√°lise da IA ML`);
            
            startMartingaleCoolingPeriod();
        }

        function startMartingaleCoolingPeriod() {
            console.log(`‚ùÑÔ∏è Iniciando cooling period de ${CONFIG.MARTINGALE_DELAYS.COOLING_PERIOD/1000}s`);
            
            martingaleState.coolingTimeout = setTimeout(() => {
                martingaleState.isInCoolingPeriod = false;
                martingaleState.isWaitingForAnalysis = true;
                
                updateMartingaleStatus('waiting', 'üß† Aguardando an√°lise da IA ML para pr√≥ximo trade');
                
                console.log('‚ùÑÔ∏è Cooling period finalizado - Aguardando an√°lise da IA ML');
                
                if (isAIConnected) {
                    requestAIAnalysisForMartingale();
                } else {
                    startManualAnalysisWait();
                }
                
            }, CONFIG.MARTINGALE_DELAYS.COOLING_PERIOD);
        }

        async function requestAIAnalysisForMartingale() {
            console.log('üß† Solicitando an√°lise da IA ML para Martingale...');
            
            try {
                updateMartingaleStatus('waiting', 'ü§ñ IA ML analisando mercado ap√≥s loss...');
                
                await getAIAnalysis();
                
                setTimeout(() => {
                    if (martingaleState.isWaitingForAnalysis) {
                        martingaleState.isWaitingForAnalysis = false;
                        martingaleState.needsAnalysisAfterLoss = false;
                        
                        updateMartingaleStatus('ready', '‚úÖ An√°lise ML conclu√≠da - Sistema pronto para operar');
                        
                        console.log('‚úÖ An√°lise da IA ML conclu√≠da - Martingale pronto para pr√≥ximo trade');
                        
                        if (isAutoTrading) {
                            console.log('ü§ñ Auto trading pode continuar ap√≥s an√°lise ML');
                        }
                    }
                }, CONFIG.MARTINGALE_DELAYS.ANALYSIS_WAIT);
                
            } catch (error) {
                console.error('‚ùå Erro na an√°lise da IA ML para Martingale:', error);
                startManualAnalysisWait();
            }
        }

        function startManualAnalysisWait() {
            console.log('‚è≥ Aguardando an√°lise manual...');
            
            updateMartingaleStatus('waiting', '‚è≥ Aguardando an√°lise manual para pr√≥ximo trade');
            
            martingaleState.analysisTimeout = setTimeout(() => {
                if (martingaleState.isWaitingForAnalysis) {
                    martingaleState.isWaitingForAnalysis = false;
                    martingaleState.needsAnalysisAfterLoss = false;
                    
                    updateMartingaleStatus('ready', '‚úÖ Tempo de an√°lise finalizado - Sistema liberado');
                    
                    console.log('‚úÖ Tempo de an√°lise manual finalizado');
                }
            }, CONFIG.MARTINGALE_DELAYS.ANALYSIS_WAIT * 2);
        }

        function canTradeWithMartingale() {
            if (martingaleState.isInCoolingPeriod) {
                console.log('üö´ Trade bloqueado: Martingale em cooling period');
                showNotification('‚ùÑÔ∏è Aguarde o cooling period do Martingale', 'warning');
                return false;
            }
            
            if (martingaleState.isWaitingForAnalysis || martingaleState.needsAnalysisAfterLoss) {
                console.log('üö´ Trade bloqueado: Aguardando an√°lise da IA ML ap√≥s loss');
                showNotification('üß† Aguarde a an√°lise da IA ML ap√≥s a perda', 'warning');
                return false;
            }
            
            const timeSinceLastTrade = Date.now() - martingaleState.lastTradeTime;
            if (timeSinceLastTrade < CONFIG.MARTINGALE_DELAYS.MIN_BETWEEN_TRADES) {
                const remainingTime = Math.ceil((CONFIG.MARTINGALE_DELAYS.MIN_BETWEEN_TRADES - timeSinceLastTrade) / 1000);
                console.log(`üö´ Trade bloqueado: Aguarde ${remainingTime}s entre trades`);
                showNotification(`‚è≥ Aguarde ${remainingTime}s entre trades`, 'warning');
                return false;
            }
            
            return true;
        }

        function updateMartingaleStatus(status, message) {
            const statusBar = document.getElementById('martingaleStatusBar');
            const martingaleInfo = document.getElementById('martingaleInfo');
            const statusValue = document.getElementById('martingaleStatusValue');
            const statusDisplay = document.getElementById('martingaleStatusDisplay');
            
            statusBar.className = `martingale-status ${status}`;
            martingaleInfo.className = `martingale-info ${status}`;
            
            statusBar.textContent = message;
            
            switch (status) {
                case 'ready':
                    statusValue.textContent = 'Pronto';
                    statusDisplay.textContent = 'Sistema Liberado';
                    break;
                case 'cooling':
                    statusValue.textContent = 'Cooling';
                    statusDisplay.textContent = 'Aguardando';
                    break;
                case 'waiting':
                    statusValue.textContent = 'An√°lise';
                    statusDisplay.textContent = 'IA ML Analisando';
                    break;
                default:
                    statusValue.textContent = 'Normal';
                    statusDisplay.textContent = 'Operando';
            }
            
            console.log(`üìä Status Martingale atualizado: ${status} - ${message}`);
        }

        function updateMartingaleDisplay() {
            document.getElementById('martingaleLevelDisplay').textContent = martingaleState.level;
            document.getElementById('nextStakeDisplay').textContent = 
                document.getElementById('stakeAmount').value;
            document.getElementById('baseStakeDisplay').textContent = 
                martingaleState.baseStake.toFixed(2);
            
            const martingaleInfo = document.getElementById('martingaleInfo');
            if (martingaleState.level === 0) {
                if (!martingaleState.isInCoolingPeriod && !martingaleState.isWaitingForAnalysis) {
                    martingaleInfo.className = 'martingale-info';
                }
            } else if (martingaleState.level <= 3) {
                if (!martingaleState.isInCoolingPeriod && !martingaleState.isWaitingForAnalysis) {
                    martingaleInfo.style.background = 'rgba(255, 165, 0, 0.1)';
                    martingaleInfo.style.borderColor = 'rgba(255, 165, 0, 0.3)';
                }
            } else {
                if (!martingaleState.isInCoolingPeriod && !martingaleState.isWaitingForAnalysis) {
                    martingaleInfo.style.background = 'rgba(255, 71, 87, 0.1)';
                    martingaleInfo.style.borderColor = 'rgba(255, 71, 87, 0.3)';
                }
            }
        }

        function validateStakeForMartingale(stake) {
            if (martingaleState.level === 0 && sessionStats.totalTrades === 0) {
                martingaleState.baseStake = stake;
                console.log('üéØ Stake base definido:', martingaleState.baseStake);
            }
            
            updateMartingaleDisplay();
            return true;
        }

        function toggleMartingale() {
            martingaleState.isActive = !martingaleState.isActive;
            const btn = document.getElementById('martingaleToggle');
            
            if (martingaleState.isActive) {
                btn.textContent = 'üé∞ Martingale: ON';
                btn.classList.remove('disabled');
                showNotification('üé∞ Martingale Inteligente ativado', 'success');
            } else {
                btn.textContent = 'üé∞ Martingale: OFF';
                btn.classList.add('disabled');
                showNotification('üé∞ Martingale desativado', 'warning');
            }
            
            console.log('üé∞ Martingale:', martingaleState.isActive ? 'ATIVO' : 'INATIVO');
        }

        function resetMartingaleManual() {
            resetMartingale();
            showNotification('üîÑ Martingale resetado manualmente', 'success');
        }

        // ==============================================
        // üìä CONTROLE DE ORDEM √öNICA REFOR√áADO
        // ==============================================

        function setActiveOrder(orderInfo) {
            orderLock = true;
            hasActiveOrder = true;
            activeOrderInfo = orderInfo;
            
            if (orderTimeout) clearTimeout(orderTimeout);
            orderTimeout = setTimeout(() => {
                console.log('‚ö†Ô∏è TIMEOUT: Limpando ordem que n√£o finalizou em 5min');
                clearActiveOrder();
            }, 300000);
            
            document.getElementById('activeOrderIndicator').classList.add('show');
            document.getElementById('activeOrderDirection').textContent = orderInfo.direction;
            document.getElementById('activeOrderStake').textContent = orderInfo.stake.toFixed(2);
            document.getElementById('activeOrderSymbol').textContent = orderInfo.symbol;
            document.getElementById('activeOrderDuration').textContent = orderInfo.duration;
            document.getElementById('activeOrderTime').textContent = new Date().toLocaleTimeString();
            
            document.getElementById('callBtn').disabled = true;
            document.getElementById('putBtn').disabled = true;
            
            console.log('üéØ Ordem ativa definida com LOCK:', orderInfo);
        }

        function clearActiveOrder() {
            if (orderTimeout) {
                clearTimeout(orderTimeout);
                orderTimeout = null;
            }
            
            hasActiveOrder = false;
            activeOrderInfo = null;
            orderLock = false;
            
            document.getElementById('activeOrderIndicator').classList.remove('show');
            
            if (isConnected && !orderLock) {
                document.getElementById('callBtn').disabled = false;
                document.getElementById('putBtn').disabled = false;
            }
            
            console.log('‚úÖ Ordem finalizada - LOCK liberado - bot√µes reabilitados');
        }

        function canPlaceNewOrder() {
            if (hasActiveOrder || orderLock) {
                const reason = hasActiveOrder ? 'ordem ativa' : 'sistema bloqueado';
                console.log(`üö´ Nova ordem BLOQUEADA: ${reason}`);
                showNotification(`‚ö†Ô∏è Aguarde - ${reason} detectada`, 'warning');
                return false;
            }
            
            if (openContracts.size > 0) {
                console.log(`üö´ Nova ordem BLOQUEADA: ${openContracts.size} contratos ainda abertos`);
                showNotification('‚ö†Ô∏è Aguarde todos os contratos finalizarem', 'warning');
                return false;
            }
            
            if (!canTradeWithMartingale()) {
                return false;
            }
            
            return true;
        }

        function checkAndCleanOrphanedOrders() {
            if (hasActiveOrder && activeOrderInfo) {
                const timeSinceOrder = Date.now() - activeOrderInfo.timestamp.getTime();
                
                if (timeSinceOrder > 180000) {
                    console.log('üßπ Limpando ordem √≥rf√£ detectada');
                    clearActiveOrder();
                }
            }
        }

        setInterval(checkAndCleanOrphanedOrders, 30000);

        // ==============================================
        // üéØ TRADING FUNCTIONS (MODIFICADAS PARA ML)
        // ==============================================

        async function placeTrade(direction) {
            if (!canPlaceNewOrder()) {
                return;
            }

            if (!isConnected) {
                showNotification('N√£o conectado √† API', 'error');
                return;
            }

            const symbol = document.getElementById('symbolSelect').value;
            let stake = parseFloat(document.getElementById('stakeAmount').value);
            let duration = parseInt(document.getElementById('duration').value);
            let durationType = document.getElementById('durationType').value;

            if (isAIDurationActive) {
                const aiDuration = await applyAIDuration();
                if (aiDuration) {
                    duration = aiDuration.duration;
                    durationType = aiDuration.type;
                    console.log(`ü§ñ IA ajustou dura√ß√£o: ${aiDuration.text}`);
                }
            }

            if (isAIManagementActive) {
                const managementDecision = await applyAIManagement();
                if (managementDecision && managementDecision.action === 'pause') {
                    showNotification('‚è∏Ô∏è IA pausou opera√ß√£o - Alto risco detectado', 'warning');
                    return;
                }
                if (managementDecision && managementDecision.recommendedStake) {
                    stake = managementDecision.recommendedStake;
                    console.log(`ü§ñ IA ajustou stake: ${stake.toFixed(2)}`);
                }
            }

            if (!validateTradeParameters(stake, duration)) {
                return;
            }

            validateStakeForMartingale(stake);

            const orderInfo = {
                direction: direction,
                symbol: symbol,
                stake: stake,
                duration: `${duration}${durationType}`,
                timestamp: new Date()
            };
            setActiveOrder(orderInfo);

            martingaleState.lastTradeTime = Date.now();

            const finalContractType = direction === 'CALL' ? 'CALL' : 'PUT';

            const buyRequest = {
                buy: 1,
                price: stake,
                parameters: {
                    amount: stake,
                    basis: "stake",
                    contract_type: finalContractType,
                    currency: accountInfo.currency || 'USD',
                    duration: duration,
                    duration_unit: durationType,
                    symbol: symbol
                }
            };

            console.log('üõí Executando trade:', buyRequest);
            const reqId = sendWSMessage(buyRequest);

            if (reqId) {
                activeOrderInfo.reqId = reqId;
                
                addTradeToTable({
                    id: reqId,
                    timestamp: new Date(),
                    symbol: symbol,
                    direction: direction,
                    stake: stake,
                    duration: `${duration}${durationType}`,
                    entry_price: currentPrice || 0,
                    status: 'open',
                    pnl: 0,
                    contract_type: finalContractType
                });

                const tradeSource = isAIModeActive ? 'IA ML' : 
                                   (isAIDurationActive || isAIManagementActive ? 'IA ML Assistida' : 'Manual');
                showNotification(`Trade ${tradeSource} ${direction}: ${symbol} - ${stake.toFixed(2)} (${duration}${durationType})`, 'success');
            } else {
                clearActiveOrder();
                showNotification('‚ùå Falha ao enviar ordem', 'error');
            }
        }

        function validateTradeParameters(stake, duration) {
            if (stake < CONFIG.MIN_STAKE) {
                showNotification(`Valor m√≠nimo da aposta √© ${CONFIG.MIN_STAKE}`, 'error');
                return false;
            }

            if (stake > CONFIG.MAX_STAKE) {
                showNotification(`Valor m√°ximo da aposta √© ${CONFIG.MAX_STAKE}`, 'error');
                return false;
            }

            if (!duration || duration <= 0) {
                showNotification('Dura√ß√£o inv√°lida', 'error');
                return false;
            }

            return true;
        }

        function handleContractUpdate(contractData) {
            console.log('üìä Atualiza√ß√£o do contrato:', contractData);
            
            if (!contractData.proposal_open_contract) return;
            
            const contract = contractData.proposal_open_contract;
            const contractId = contract.contract_id;
            
            if (!openContracts.has(contractId)) {
                console.log('‚ö†Ô∏è Contrato n√£o monitorado:', contractId);
                return;
            }

            if (contract.is_sold) {
                console.log('üèÅ Contrato finalizado:', contractId);
                
                const trackedContract = openContracts.get(contractId);
                if (trackedContract) {
                    const pnl = parseFloat(contract.profit) || 0;
                    const isWin = pnl > 0;
                    
                    console.log(`üìä Resultado: ${isWin ? 'WIN' : 'LOSS'} - P&L: ${pnl.toFixed(2)}`);
                    
                    sessionStats.totalPnL += pnl;
                    sessionStats.totalTrades++;
                    
                    if (isWin) {
                        sessionStats.wonTrades++;
                        if (martingaleState.isActive) {
                            resetMartingale();
                        }
                    } else {
                        sessionStats.lostTrades++;
                        if (martingaleState.isActive) {
                            applyMartingale();
                        }
                    }
                    
                    updateSessionStats();
                    
                    updateTradeInTable(contractId, {
                        status: isWin ? 'won' : 'lost',
                        pnl: pnl,
                        exit_price: contract.exit_tick || contract.current_spot
                    });
                    
                    // ü§ñ NOTIFICAR ML COM RESULTADO DO TRADE
                    if (window.notifyMLTrade) {
                        window.notifyMLTrade({
                            direction: trackedContract.direction || orderInfo?.direction,
                            pnl: pnl,
                            success: isWin,
                            symbol: trackedContract.symbol || orderInfo?.symbol,
                            martingaleLevel: martingaleState.level,
                            stake: trackedContract.buy_price || orderInfo?.stake,
                            timestamp: new Date().toISOString()
                        });
                    }
                    
                    if (activeOrderInfo && activeOrderInfo.contractId === contractId) {
                        console.log('üîì Limpando ordem ativa - contrato finalizado');
                        clearActiveOrder();
                    }
                    
                    openContracts.delete(contractId);
                    contractSubscriptions.delete(contractId);
                    
                    showNotification(
                        `üèÅ Trade finalizado: ${isWin ? 'WIN' : 'LOSS'} ${pnl.toFixed(2)}`,
                        isWin ? 'success' : 'error'
                    );
                    
                    sendWSMessage({ balance: 1 });
                    
                    console.log(`‚úÖ Sistema liberado: hasActiveOrder=${hasActiveOrder}, orderLock=${orderLock}, openContracts=${openContracts.size}`);
                }
            } else if (contract.status === 'open') {
                const unrealizedPnl = parseFloat(contract.profit) || 0;
                console.log(`üìà P&L n√£o realizado (${contractId.toString().slice(-6)}): ${unrealizedPnl.toFixed(2)}`);
                
                if (activeOrderInfo && !activeOrderInfo.contractId && trackedContract && trackedContract.reqId === activeOrderInfo.reqId) {
                    console.log('üîó Associando contrato tardio √† ordem ativa');
                    activeOrderInfo.contractId = contractId;
                }
            }
        }

        function toggleAutoTrading() {
            const tradingMode = document.getElementById('tradingMode').value;
            
            if (tradingMode === 'ai' && !isAIConnected) {
                showNotification('IA n√£o conectada! Conecte primeiro.', 'error');
                return;
            }
            
            isAutoTrading = !isAutoTrading;
            const button = document.getElementById('autoBtn');
            
            if (isAutoTrading) {
                button.textContent = '‚èπÔ∏è Parar Auto';
                button.className = 'trade-btn stop';
                updateStatus('tradingStatus', 'online');
                
                if (tradingMode === 'ai') {
                    showNotification('ü§ñ Auto trading com IA ML iniciado', 'success');
                    startAITradingCycle();
                } else {
                    showNotification('ü§ñ Auto trading inteligente iniciado', 'success');
                    startAutoTrading();
                }
            } else {
                button.textContent = 'ü§ñ Iniciar Auto';
                updateStatus('tradingStatus', 'offline');
                showNotification('ü§ñ Auto trading parado', 'warning');
                isAIModeActive = false;
            }
        }

        function startAutoTrading() {
            if (!isAutoTrading || !isConnected) {
                console.log('üõë Auto trading parado ou desconectado');
                return;
            }

            if (!canPlaceNewOrder()) {
                console.log(`‚è∏Ô∏è Auto trading aguardando libera√ß√£o do sistema`);
                
                setTimeout(startAutoTrading, 3000);
                return;
            }

            console.log('ü§ñ Auto trading: Sistema completamente livre - preparando novo trade');

            const symbols = ['R_10', 'R_25', 'R_50', 'R_75', 'R_100'];
            const randomSymbol = symbols[Math.floor(Math.random() * symbols.length)];
            const direction = Math.random() > 0.5 ? 'CALL' : 'PUT';

            document.getElementById('symbolSelect').value = randomSymbol;
            
            setTimeout(() => {
                if (isAutoTrading && canPlaceNewOrder()) {
                    console.log(`üöÄ Auto trading executando: ${direction} em ${randomSymbol}`);
                    placeTrade(direction);
                } else {
                    console.log('‚ö†Ô∏è Auto trading cancelado - sistema n√£o livre ou Martingale bloqueando');
                }
            }, 2000);
            
            if (isAutoTrading) {
                const nextTradeDelay = CONFIG.AUTO_TRADE_DELAY.MIN + 
                    Math.random() * (CONFIG.AUTO_TRADE_DELAY.MAX - CONFIG.AUTO_TRADE_DELAY.MIN);
                
                console.log(`‚è∞ Pr√≥ximo auto trade em ${(nextTradeDelay/1000).toFixed(1)}s`);
                setTimeout(startAutoTrading, nextTradeDelay);
            }
        }

        function toggleAIMode() {
            isAIModeActive = !isAIModeActive;
            const btn = document.getElementById('aiModeBtn');
            
            if (isAIModeActive) {
                btn.textContent = 'ü§ñ Modo IA: ON';
                btn.classList.add('active');
                showNotification('ü§ñ Modo IA ML ativado - Trades autom√°ticos com ML', 'success');
                
                startAITradingCycle();
            } else {
                btn.textContent = 'ü§ñ Modo IA: OFF';
                btn.classList.remove('active');
                showNotification('ü§ñ Modo IA ML desativado', 'warning');
            }
        }

        async function startAITradingCycle() {
            if (!isAIModeActive || !isAIConnected) return;

            try {
                await getAIAnalysis();
                await new Promise(resolve => setTimeout(resolve, 5000));
                
                await getAIRiskAssessment();
                await new Promise(resolve => setTimeout(resolve, 5000));
                
                await getAITradingSignal();
                
                if (isAIModeActive) {
                    setTimeout(startAITradingCycle, 60000);
                }
            } catch (error) {
                console.error('‚ùå Erro no ciclo IA ML:', error);
            }
        }

        function toggleAIDurationControl() {
            isAIDurationActive = !isAIDurationActive;
            const btn = document.getElementById('aiDurationBtn');
            
            if (isAIDurationActive) {
                btn.textContent = '‚è±Ô∏è Dura√ß√£o IA: ON';
                btn.classList.add('active');
                showNotification('‚è±Ô∏è IA ML controla dura√ß√£o automaticamente', 'success');
            } else {
                btn.textContent = '‚è±Ô∏è Dura√ß√£o IA: OFF';
                btn.classList.remove('active');
                showNotification('‚è±Ô∏è Controle manual de dura√ß√£o', 'warning');
            }
        }

        function toggleAIManagement() {
            isAIManagementActive = !isAIManagementActive;
            const btn = document.getElementById('aiManagementBtn');
            
            if (isAIManagementActive) {
                btn.textContent = 'üéõÔ∏è Gerenciamento IA: ON';
                btn.classList.add('active');
                showNotification('üéõÔ∏è IA ML gerencia opera√ß√µes automaticamente', 'success');
                
                document.getElementById('aiManagement').classList.add('show');
                document.getElementById('aiManagementText').textContent = 'IA ML controlando dura√ß√£o e stake automaticamente';
                updateStatus('aiManagementStatus', 'online');
            } else {
                btn.textContent = 'üéõÔ∏è Gerenciamento IA: OFF';
                btn.classList.remove('active');
                showNotification('üéõÔ∏è Gerenciamento manual', 'warning');
                
                document.getElementById('aiManagement').classList.remove('show');
                updateStatus('aiManagementStatus', 'offline');
            }
        }

        async function applyAIDuration() {
            if (!isAIDurationActive) return null;
            
            // Simula√ß√£o de dura√ß√£o inteligente da IA ML
            const durationTypes = ['t', 'm'];
            const randomType = durationTypes[Math.floor(Math.random() * durationTypes.length)];
            
            let duration;
            if (randomType === 't') {
                duration = Math.floor(Math.random() * 5) + 3; // 3-7 ticks
            } else {
                duration = Math.floor(Math.random() * 3) + 1; // 1-3 minutos
            }
            
            document.getElementById('durationType').value = randomType;
            document.getElementById('duration').value = duration;
            updateDurationOptions();
            document.getElementById('duration').value = duration;
            
            return {
                type: randomType,
                duration: duration,
                text: `${duration}${randomType}`
            };
        }

        async function applyAIManagement() {
            if (!isAIManagementActive) return null;
            
            // Simula√ß√£o de gerenciamento inteligente ML
            const currentStake = parseFloat(document.getElementById('stakeAmount').value);
            
            // Reduzir stake se Martingale muito alto
            if (martingaleState.level > 4) {
                return {
                    action: 'pause',
                    reason: 'Martingale muito alto - pausando opera√ß√µes'
                };
            }
            
            // Ajustar stake baseado no risco ML
            if (sessionStats.totalTrades > 0) {
                const winRate = (sessionStats.wonTrades / sessionStats.totalTrades) * 100;
                
                if (winRate < 40) {
                    const reducedStake = Math.max(CONFIG.MIN_STAKE, currentStake * 0.8);
                    return {
                        action: 'adjust',
                        recommendedStake: reducedStake,
                        reason: 'Taxa de acerto baixa - reduzindo stake'
                    };
                }
            }
            
            return {
                action: 'continue',
                reason: 'Condi√ß√µes normais de opera√ß√£o'
            };
        }

        // ==============================================
        // üåê CONEX√ÉO E WEBSOCKET
        // ==============================================

        async function connectAPI() {
            const token = document.getElementById('apiToken').value.trim();
            const accountType = document.getElementById('accountType').value;
            
            if (!token) {
                showNotification('Por favor, insira seu token de API', 'error');
                return;
            }

            setLoginLoading(true);
            apiToken = token;

            const aiConnected = await connectToAI();
            if (!aiConnected) {
                showNotification('‚ö†Ô∏è Continuando sem IA ML Real...', 'warning');
            }

            ws = new WebSocket(CONFIG.WS_URL);

            ws.onopen = function() {
                console.log('‚úÖ WebSocket conectado');
                updateStatus('wsStatus', 'online');
                
                sendWSMessage({
                    authorize: token
                });
            };

            ws.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    handleWSMessage(data);
                } catch (error) {
                    console.error('‚ùå Erro ao processar mensagem:', error);
                }
            };

            ws.onclose = function() {
                console.log('‚ùå WebSocket desconectado');
                updateStatus('wsStatus', 'offline');
                updateStatus('apiStatus', 'offline');
                isConnected = false;
                setLoginLoading(false);
            };

            ws.onerror = function(error) {
                console.error('‚ùå Erro WebSocket:', error);
                showNotification('Erro de conex√£o. Verifique seu token.', 'error');
                setLoginLoading(false);
            };
        }

        function handleWSMessage(data) {
            console.log('üì® Mensagem recebida:', data.msg_type, data);

            switch (data.msg_type) {
                case 'authorize':
                    handleAuthorization(data);
                    break;
                case 'balance':
                    handleBalance(data);
                    break;
                case 'tick':
                    handleTick(data);
                    break;
                case 'buy':
                    handleTradeCreated(data);
                    break;
                case 'proposal':
                    handleProposal(data);
                    break;
                case 'portfolio':
                    handlePortfolio(data);
                    break;
                case 'proposal_open_contract':
                    handleContractUpdate(data);
                    break;
                default:
                    if (data.error) {
                        handleError(data.error);
                    }
            }
        }

        function handleAuthorization(data) {
            if (data.authorize && data.authorize.loginid) {
                console.log('‚úÖ Autoriza√ß√£o bem-sucedida');
                isConnected = true;
                updateStatus('apiStatus', 'online');
                
                accountInfo = data.authorize;
                const accountType = document.getElementById('accountType').value;
                const accountTypeLabel = accountType === 'demo' ? 'üéÆ DEMO' : 'üí∞ REAL';
                
                document.getElementById('accountInfo').textContent = 
                    `${data.authorize.loginid} - ${data.authorize.currency} (${accountTypeLabel})`;
                
                initializeUserData();
                
                showDashboard();
                setLoginLoading(false);
                
                const successMessage = accountType === 'demo' 
                    ? 'üéÆ Conectado √† conta DEMO com IA ML Real!'
                    : 'üí∞ Conectado √† conta REAL com IA ML Real!';
                showNotification(successMessage, 'success');
            } else {
                showNotification('Token inv√°lido', 'error');
                setLoginLoading(false);
            }
        }

        function initializeUserData() {
            sendWSMessage({ balance: 1 });
            sendWSMessage({ portfolio: 1, subscribe: 1 });
        }

        function handleBalance(data) {
            if (data.balance) {
                updateBalance(data.balance.balance, data.balance.currency);
                if (sessionStats.startBalance === 0) {
                    sessionStats.startBalance = parseFloat(data.balance.balance);
                }
            }
        }

        function handleTick(data) {
            if (data.tick) {
                currentPrice = parseFloat(data.tick.quote);
                console.log(`üìä Novo tick: ${data.tick.symbol} = ${currentPrice.toFixed(4)}`);
            }
        }

        function handleProposal(data) {
            if (data.proposal) {
                console.log('üí∞ Proposta recebida:', data.proposal);
            }
        }

        function handleError(error) {
            console.error('‚ùå Erro API:', error);
            showNotification(`Erro: ${error.message}`, 'error');
        }

        function handleTradeCreated(buyData) {
            console.log('‚úÖ Trade criado:', buyData);
            
            if (buyData.buy) {
                const contractId = buyData.buy.contract_id;
                const buyPrice = buyData.buy.buy_price;
                const reqId = buyData.req_id;
                
                if (contractId) {
                    if (activeOrderInfo && activeOrderInfo.reqId === reqId) {
                        activeOrderInfo.contractId = contractId;
                        console.log('üîó Contrato associado √† ordem ativa:', contractId);
                    }

                    openContracts.set(contractId, {
                        id: contractId,
                        buy_price: buyPrice,
                        start_time: Date.now(),
                        symbol: buyData.buy.shortcode || 'Unknown',
                        reqId: reqId,
                        direction: activeOrderInfo?.direction
                    });

                    sendWSMessage({
                        proposal_open_contract: 1,
                        contract_id: contractId,
                        subscribe: 1
                    });

                    contractSubscriptions.set(contractId, {
                        subscribed: true,
                        timestamp: Date.now()
                    });

                    sendWSMessage({ balance: 1 });
                    
                    showNotification(`‚úÖ Contrato criado: ${contractId.toString().slice(-6)}`, 'success');
                } else {
                    console.error('‚ùå Contrato criado sem ID');
                    clearActiveOrder();
                }
            } else {
                console.error('‚ùå Falha na cria√ß√£o do trade');
                clearActiveOrder();
            }
        }

        function handlePortfolio(portfolioData) {
            console.log('üíº Portfolio atualizado:', portfolioData);
            
            if (portfolioData.portfolio && portfolioData.portfolio.contracts) {
                portfolioData.portfolio.contracts.forEach(contract => {
                    const contractId = contract.contract_id;
                    
                    if (contractId && !contract.is_sold && !contractSubscriptions.has(contractId)) {
                        console.log('üîç Novo contrato encontrado no portfolio:', contractId);
                        
                        sendWSMessage({
                            proposal_open_contract: 1,
                            contract_id: contractId,
                            subscribe: 1
                        });
                        
                        contractSubscriptions.set(contractId, {
                            subscribed: true,
                            timestamp: Date.now()
                        });
                    }
                });
            }
        }

        function sendWSMessage(message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const msgWithReqId = { ...message, req_id: Date.now() };
                ws.send(JSON.stringify(msgWithReqId));
                console.log('üì§ Enviando:', msgWithReqId);
                return msgWithReqId.req_id;
            } else {
                console.error('‚ùå WebSocket n√£o conectado');
                return null;
            }
        }

        // ==============================================
        // üìä FUN√á√ïES DE INTERFACE E UTILIT√ÅRIOS
        // ==============================================

        function calculateVolatility() {
            if (trades.length < 3) return 50;
            
            const recentPrices = trades.slice(-10).map(t => t.entry_price || currentPrice);
            const avg = recentPrices.reduce((a, b) => a + b, 0) / recentPrices.length;
            const variance = recentPrices.reduce((sum, price) => sum + Math.pow(price - avg, 2), 0) / recentPrices.length;
            const volatility = Math.sqrt(variance) / avg * 100;
            
            return Math.min(100, Math.max(10, volatility));
        }

        function analyzeMarketCondition() {
            const recentResults = trades.slice(-5);
            if (recentResults.length === 0) return 'neutral';
            
            const wins = recentResults.filter(t => t.status === 'won').length;
            const winRate = wins / recentResults.length;
            
            if (winRate > 0.7) return 'favorable';
            if (winRate < 0.3) return 'unfavorable';
            return 'neutral';
        }

        function updateBalance(balance, currency) {
            const formattedBalance = parseFloat(balance).toFixed(2);
            document.getElementById('balance').textContent = `${currency} ${formattedBalance}`;
            
            if (sessionStats.startBalance > 0) {
                const change = parseFloat(balance) - sessionStats.startBalance;
                const changePercent = (change / sessionStats.startBalance) * 100;
                
                const changeElement = document.getElementById('balanceChange');
                changeElement.innerHTML = `
                    <span>${change >= 0 ? '‚Üó' : '‚Üò'}</span> 
                    ${change >= 0 ? '+' : ''}${change.toFixed(2)} (${changePercent.toFixed(2)}%)
                `;
                changeElement.className = `metric-change ${change >= 0 ? 'positive' : 'negative'}`;
            }
        }

        function updateSessionStats() {
            const winRate = sessionStats.totalTrades > 0 
                ? (sessionStats.wonTrades / sessionStats.totalTrades) * 100 
                : 0;
            
            document.getElementById('winRate').textContent = winRate.toFixed(1) + '%';
            document.getElementById('tradesCount').textContent = sessionStats.totalTrades;
            document.getElementById('todayPnL').textContent = `${sessionStats.totalPnL.toFixed(2)}`;
            
            const winRateElement = document.getElementById('winRateChange');
            winRateElement.innerHTML = `<span>‚Üó</span> ${sessionStats.wonTrades}W / ${sessionStats.lostTrades}L`;
            
            const tradesElement = document.getElementById('tradesChange');
            tradesElement.innerHTML = `<span>‚Üó</span> ${sessionStats.wonTrades} wins, ${sessionStats.lostTrades} losses`;
            
            const pnlElement = document.getElementById('pnlChange');
            pnlElement.innerHTML = `
                <span>${sessionStats.totalPnL >= 0 ? '‚Üó' : '‚Üò'}</span> 
                ${sessionStats.totalPnL >= 0 ? 'Lucro' : 'Preju√≠zo'} sess√£o
            `;
            pnlElement.className = `metric-change ${sessionStats.totalPnL >= 0 ? 'positive' : 'negative'}`;
        }

        function addTradeToTable(trade) {
            const tbody = document.getElementById('tradesTableBody');
            
            if (tbody.innerHTML.includes('Nenhum trade')) {
                tbody.innerHTML = '';
            }
            
            const row = document.createElement('div');
            row.className = 'trades-grid';
            row.id = `trade-${trade.id}`;
            
            row.innerHTML = `
                <div>${trade.id.toString().slice(-6)}</div>
                <div>${trade.timestamp.toLocaleTimeString()}</div>
                <div>${trade.symbol}</div>
                <div><span class="trade-direction ${trade.direction.toLowerCase()}">${trade.direction}</span></div>
                <div>${trade.stake.toFixed(2)}</div>
                <div>${trade.duration}</div>
                <div>${trade.entry_price.toFixed(4)}</div>
                <div><span class="trade-status ${trade.status}">${trade.status.toUpperCase()}</span></div>
                <div class="${trade.pnl >= 0 ? 'positive' : 'negative'}">${trade.pnl.toFixed(2)}</div>
            `;
            
            tbody.insertBefore(row, tbody.firstChild);
            
            while (tbody.children.length > 15) {
                tbody.removeChild(tbody.lastChild);
            }
        }

        function updateTradeInTable(contractId, updates) {
            const trackedContract = openContracts.get(contractId);
            if (!trackedContract) return;
            
            const reqId = trackedContract.reqId;
            const row = document.getElementById(`trade-${reqId}`);
            
            if (row) {
                const cells = row.children;
                
                if (updates.status) {
                    const statusCell = cells[7];
                    statusCell.innerHTML = `<span class="trade-status ${updates.status}">${updates.status.toUpperCase()}</span>`;
                }
                
                if (updates.pnl !== undefined) {
                    const pnlCell = cells[8];
                    pnlCell.innerHTML = `${updates.pnl.toFixed(2)}`;
                    pnlCell.className = updates.pnl >= 0 ? 'positive' : 'negative';
                }
                
                console.log(`‚úÖ Trade atualizado na tabela: ${reqId} -> ${updates.status}`);
            } else {
                console.log(`‚ö†Ô∏è Trade n√£o encontrado na tabela: ${reqId}`);
            }
        }

        function updateStatus(elementId, status) {
            const element = document.getElementById(elementId);
            if (element) {
                element.className = `status-dot ${status}`;
            }
        }

        function showDashboard() {
            document.getElementById('loginModal').style.display = 'none';
            document.getElementById('dashboard').style.display = 'block';
            
            const accountType = document.getElementById('accountType').value;
            const headerTitle = document.querySelector('.header h1');
            if (accountType === 'demo') {
                headerTitle.textContent = 'üéÆ Trading Bot - DEMO + IA ML Real';
            } else {
                headerTitle.textContent = 'üí∞ Trading Bot - REAL + IA ML Real';
            }
            
            document.getElementById('callBtn').disabled = false;
            document.getElementById('putBtn').disabled = false;
            document.getElementById('autoBtn').disabled = false;
        }

        function setLoginLoading(loading) {
            const btn = document.getElementById('loginBtn');
            const text = document.getElementById('loginBtnText');
            const spinner = document.getElementById('loginSpinner');
            
            btn.disabled = loading;
            text.style.display = loading ? 'none' : 'block';
            spinner.style.display = loading ? 'block' : 'none';
        }

        function showNotification(message, type = 'info') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type} show`;
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 5000);
        }

        function logout() {
            if (ws) {
                ws.close();
            }
            
            resetApplicationState();
            
            document.getElementById('loginModal').style.display = 'flex';
            document.getElementById('dashboard').style.display = 'none';
            document.getElementById('apiToken').value = '';
            document.getElementById('connectionMethod').textContent = 'Desconectado';
            updateStatus('apiStatus', 'offline');
            updateStatus('wsStatus', 'offline');
            updateStatus('aiStatus', 'offline');
            updateStatus('tradingStatus', 'offline');
            updateStatus('aiManagementStatus', 'offline');
            
            showNotification('Desconectado com sucesso', 'success');
        }

        function resetApplicationState() {
            isConnected = false;
            isAutoTrading = false;
            isAIConnected = false;
            isAIModeActive = false;
            isAIDurationActive = false;
            isAIManagementActive = false;
            mlModelsLoaded = false;
            
            hasActiveOrder = false;
            activeOrderInfo = null;
            orderLock = false;
            if (orderTimeout) {
                clearTimeout(orderTimeout);
                orderTimeout = null;
            }
            contractSubscriptions.clear();
            
            apiToken = '';
            accountInfo = {};
            trades = [];
            openContracts.clear();
            mlTrainingData = [];
            sessionStats = {
                totalTrades: 0,
                wonTrades: 0,
                lostTrades: 0,
                totalPnL: 0,
                startBalance: 0
            };
            
            if (martingaleState.coolingTimeout) {
                clearTimeout(martingaleState.coolingTimeout);
            }
            if (martingaleState.analysisTimeout) {
                clearTimeout(martingaleState.analysisTimeout);
            }
            
            martingaleState = {
                level: 0,
                baseStake: 1,
                maxLevel: 8,
                isActive: true,
                sequence: [],
                multiplier: 2,
                isInCoolingPeriod: false,
                isWaitingForAnalysis: false,
                lastTradeTime: 0,
                needsAnalysisAfterLoss: false,
                coolingTimeout: null,
                analysisTimeout: null
            };
            
            aiData = {
                lastAnalysis: null,
                lastSignal: null,
                confidence: 0,
                riskLevel: 'medium',
                optimalDuration: null,
                managementDecision: null,
                lastDurationUpdate: null,
                mlStats: null,
                technicalIndicators: null,
                modelAccuracy: {}
            };
            
            initializeMartingale();
            enableAIControls(false);
            clearActiveOrder();
            
            console.log('üîÑ Estado da aplica√ß√£o resetado completamente');
        }

        // ==============================================
        // üöÄ INICIALIZA√á√ÉO E SETUP
        // ==============================================

        document.addEventListener('DOMContentLoaded', function() {
            console.log('üöÄ Iniciando Trading Bot com Machine Learning Real...');
            initializeApplication();
        });

        function initializeApplication() {
            updateDurationOptions();
            setupEventListeners();
            initializeMartingale();
            
            console.log('‚úÖ Aplica√ß√£o ML Real inicializada com sucesso');
        }

        function setupEventListeners() {
            document.getElementById('apiToken').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    connectAPI();
                }
            });

            document.getElementById('stakeAmount').addEventListener('input', function() {
                const stake = parseFloat(this.value);
                validateStakeAmount();
                
                if (martingaleState.level === 0) {
                    martingaleState.baseStake = stake || 1;
                    updateMartingaleDisplay();
                }
            });
        }

        function selectAccountType(type) {
            const demoCard = document.getElementById('demoCard');
            const realCard = document.getElementById('realCard');
            const accountSelect = document.getElementById('accountType');
            
            demoCard.classList.remove('selected');
            realCard.classList.remove('selected');
            
            if (type === 'demo') {
                demoCard.classList.add('selected');
                accountSelect.value = 'demo';
                showNotification('üí° Conta Demo selecionada - IA ML Real!', 'info');
            } else {
                realCard.classList.add('selected');
                accountSelect.value = 'real';
                showNotification('‚ö†Ô∏è Conta Real - IA ML Real com cuidado!', 'warning');
            }
            
            console.log(`üîÑ Tipo de conta selecionado: ${type}`);
        }

        function updateDurationOptions() {
            const durationType = document.getElementById('durationType').value;
            const durationSelect = document.getElementById('duration');
            
            durationSelect.innerHTML = '';
            
            DURATION_OPTIONS[durationType].forEach(option => {
                const optElement = document.createElement('option');
                optElement.value = option.value;
                optElement.textContent = option.label;
                if (durationType === 't' && option.value === 5) optElement.selected = true;
                if (durationType === 'm' && option.value === 1) optElement.selected = true;
                durationSelect.appendChild(optElement);
            });
        }

        function validateStakeAmount() {
            const stakeInput = document.getElementById('stakeAmount');
            const value = parseFloat(stakeInput.value);
            
            if (value < CONFIG.MIN_STAKE) {
                stakeInput.value = CONFIG.MIN_STAKE;
                showNotification(`Valor m√≠nimo da aposta √© ${CONFIG.MIN_STAKE}`, 'warning');
            } else if (value > CONFIG.MAX_STAKE) {
                stakeInput.value = CONFIG.MAX_STAKE;
                showNotification(`Valor m√°ximo da aposta √© ${CONFIG.MAX_STAKE}`, 'warning');
            }
        }

        // üîÑ VERIFICA√á√ÉO PERI√ìDICA DA IA ML
        setInterval(async () => {
            if (isAIConnected) {
                try {
                    const response = await fetch(`${CONFIG.AI_API_URL}/api/health`);
                    if (response.ok) {
                        const data = await response.json();
                        document.getElementById('connectionMethod').textContent = 
                            `Python ML API (${data.ml_status?.models_available?.length || 0} modelos)`;
                        
                        if (data.ml_status) {
                            updateMLDisplay(data.ml_status);
                        }
                    } else {
                        throw new Error('API n√£o responde');
                    }
                } catch (error) {
                    document.getElementById('connectionMethod').textContent = 'Python ML API Offline';
                    document.getElementById('apiKeyStatus').textContent = 'Erro';
                    updateStatus('aiStatus', 'warning');
                }
            }
        }, 30000); // Verificar a cada 30 segundos

        // üìä LOGS FINAIS
        console.log('üéØ Trading Bot com MACHINE LEARNING REAL carregado!');
        console.log('‚öôÔ∏è Configura√ß√µes:', CONFIG);
        console.log('ü§ñ FUNCIONALIDADES DA IA ML REAL:');
        console.log('   üß† Random Forest + Neural Network + Gradient Boosting');
        console.log('   üìà Indicadores t√©cnicos reais (RSI, MACD, Bollinger, EMAs)');
        console.log('   üéì Aprendizado cont√≠nuo com feedback dos trades');
        console.log('   üéØ Predi√ß√µes inteligentes com ensemble de modelos');
        console.log('   ‚ö†Ô∏è Avalia√ß√£o multifatorial de risco com ML');
        console.log('   ‚è±Ô∏è Controle autom√°tico de dura√ß√£o otimizada');
        console.log('   üéõÔ∏è Gerenciamento autom√°tico de stake inteligente');
        console.log('   üé∞ Martingale inteligente anti-loop');
        console.log('   üìä An√°lise de regime de mercado e volatilidade');
        console.log('‚úÖ SISTEMA MACHINE LEARNING REAL COMPLETO E FUNCIONAL!');
    </script>
</body>
</html>
